<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>cal448 - Documentation</title>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:700,300" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="css/style.css">
<link rel="stylesheet" href="css/prettify.css">
  
<script src="js/jquery.min.js"></script>  
<script type="text/javascript" src="js/prettify/prettify.js"></script> 
<script src="js/layout.js"></script>
<script src="js/jquery.localscroll-1.2.7.js" type="text/javascript"></script>
<script src="js/jquery.scrollTo-1.4.3.1.js" type="text/javascript"></script>
  
</head>

<nav>
  <div class="container">
    <img class="header-image" src="grey-logo-vector.svg">
    <div id="menu">
      <ul class="toplinks">
        <li><a href="https://github.com/sahilhirani/EECS_448" target="_blank">GitHub Link </a></li>
      </ul>
    </div>
    <a id="menu-toggle" href="#" class=" ">&#9776;</a> 
  </div>
</nav>
<header>
  <div class="container">
    <h2 class="docs-header"> <strong>cal</strong>448 - Documentation</h2>
  </div>
</header>
<section>
  <div class="container">
    
<!--  the list below is the side navigation, linking not working properly  -->
    
    <ul class="docs-nav" id="menu-left">
      <li><strong>Getting Started</strong></li>
      <li><a href="#welcome">Welcome</a></li>
      <li><a href="#use">How to Use</a></li>
      <li><a href="#features" class=" ">Features</a></li>
      <li><a href="#license" class=" ">License</a></li>
      <li class="separator"></li>
      <li><strong>cal448 Classes & Files</strong></li>
      <li><a href="#main-cpp" class=" ">Main.cpp</a></li>
      <li><a href="#executive" class=" ">Executive Class</a></li>
      <li><a href="#linked-list" class=" ">LinkedList Class</a></li>
      <li><a href="#node" class=" ">Node Class</a></li>
      <li><a href="#event-class" class=" ">Events Class</a></li>
      <li><a href="#time-slots" class=" ">Time Slots Class</a></li>
    </ul>
    
<!--  getting started/welcome section  -->
    
    <div class="docs-content">
      <h2> Getting Started</h2>
      <h3 id="welcome"> Welcome</h3>
      <p> Are you ready to experience truly optimized scheduling?</p>
      
      <p>
        <strong>cal</strong>448 aims to provide users with an efficient and easy to use option to the confusing world of scheduling. Our terminal based application is built using the highest standards and we're sure that you'll love using it! Scroll down to get started and to find in-depth documentation for each of the classes used. With <strong>cal</strong>448 users are able to:
      </p>

      <ul>
        <li>Choose between an Admin or User Mode</li>
        <li>Create truly personalized events</li>
        <li>Assign availability and view number of attendees</li>
      </ul>
      
      <p>
        <strong>cal</strong>448 allows users to do all of this and so much more without having to use a convoluted web or desktop application. Everything is as simple as it can possibly be! For instructions on how to use <strong>cal</strong>448, scroll down to the <a href="#use">How to Use</a> section.
      </p>
      
<!--   how to use section   -->
      
      <h3 id="use"> How to Use</h3>
      <p>
        To install:
      </p>
      
      <ul>
        <li>Head to the GitHub page linked at the <a onclick="toTop()">top</a> of this site</li>
        <li>Clone or download a zip of the project</li>
        <li>Open terminal and navigate to the directory that the project was cloned/downloaded to</li>
        <li>Once in the correct directory, type "make". The program should now compile</li>
        <li>After the program completes compiling, simply type "./cal488" and the program will run</li>
      </ul>
      
      <p>In pictures (after clone/download):</p>
      
      <img class="instruction-imgs" src="/documentation/images/1.png">
      <img class="instruction-imgs" src="/documentation/images/2.png">
      <img class="instruction-imgs" src="/documentation/images/3.png">
      
<!--   features section   -->
      
      <h3 id="features"> Features</h3>
      <ul>
        <li>Scheduling in a simplified and easy manner</li>
        <li>Ability to see number of attendees for events</li>
        <li>Codebase in C++ allowing for simple understanding</li>
        <li>Functional user interface that works (no guessing)</li>
      </ul>
      
<!--   license section   -->
      
      <h3 id="license"> License</h3>
      <p> 
        <strong>cal</strong>448 holds an <a href="https://opensource.org/licenses/MIT" target="_blank">MIT license.</a> This means that all code provided is free of charge and can be modified to fit the needs of you or your organization. No reference to the project page on GitHub is required. This project's documentation website is sourced from eGrappler. Link provided at the <a onclick="toBottom()">bottom</a> of this site.
      </p>
      
      <hr>
      
      <h2> <strong>cal</strong>448 Classes & Files</h2>
      <p>
        Below you will find every function/method/class variable used in <strong>cal</strong>448
      </p>
      
<!--   this is where the classes are documented   -->
      
      <h3 id="main-cpp"> Main.cpp</h3>
      <p># main( ) function</p>
      <ul>
        <li>Preconditions: None</li>
        <li>Postconditions: None</li>
        <li>Parameters: None</li>
        <li>Access: Public</li>
        <li>Action: Creates an instance of the Executive class and runs the program.</li>
      </ul>
      
      <pre class="prettyprint">&lt;code&gt;
    int main() 
    {
      Executive exec;
      exec.run();

      return(0);
    }
&lt;/code&gt;</pre>
      
<!--   Executive   -->
      
      <h3 id="executive"> Executive.h & Executive.cpp</h3>
      
      <p># .... method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: None </li>
        <li>Action: None</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', animation_speed:'slow'});
    })	
&lt;/code&gt; </pre>
      
      <p># .... method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: None </li>
        <li>Action: None</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', animation_speed:'slow'});
    })	
&lt;/code&gt; </pre>
      
      <p># .... method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: None </li>
        <li>Action: None</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', animation_speed:'slow'});
    })	
&lt;/code&gt; </pre>
      
      <p># .... method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: None </li>
        <li>Action: None</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', animation_speed:'slow'});
    })	
&lt;/code&gt; </pre>
     
      <p># .... method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: None </li>
        <li>Action: None</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', animation_speed:'slow'});
    })	
&lt;/code&gt; </pre>

<!--  linked list    -->

      <h3 id="linked-list"> LinkedList.h & LinkedList.hpp</h3>
      
      <p># LinkedList( ) method</p>
      <ul>
        <li>Preconditions: None</li>
        <li>Postconditions: An empty LinkedList object is created</li>
        <li>Parameters: None</li>
        <li>Access: Public</li>
        <li>Action: Assigns private member variables and creates an empty list</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    LinkedList&lt;T&gt;::LinkedList()
    {
      m_front = nullptr;
      m_length = 0;
    }
&lt;/code&gt; </pre>
      
      <p># ~LinkedList( ) method</p>
      <ul>
        <li>Preconditions: None</li>
        <li>Postconditions: All nodes in the LinkedList object are deleted</li>
        <li>Parameters: None</li>
        <li>Access: Public</li>
        <li>Action: Each element in the list is traversed and removed until no more exist</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    LinkedList&lt;T&gt;::~LinkedList( )
    {
      while(m_front != nullptr) 
      {
        removeFront();
      }
    }
&lt;/code&gt; </pre>
      
      <p># isEmpty( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Checks to see if the value associated with the private member variable 'm_length' is greater than 0. If it is, 'false' will be returned. 'true' otherwise. </li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::isEmpty( )
    {
      if(m_length == 0) 
      {
        return(true);
      }
      else
      {
        return(false);
      }
    }	
&lt;/code&gt; </pre>
     
      <p># getLength( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Returns the value associated with the number of nodes that are in the list at the time called.</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    int LinkedList&lt;T&gt;::getLength( ) const
    {
      return(m_length);
    }
&lt;/code&gt; </pre>
      
      <p># positionOf( T value ) method</p>
      <ul>
        <li>Preconditions: T's type is overloaded with the '==' operator </li>
        <li>Postconditions: None </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Returns the index associated with the templated value. If it does not exist in the list, the user is notified.</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    int LinkedList&lt;T&gt;::positionOf( T value ) const
    {
      int val = 0;
      Node&lt;T&gt;* temp = m_front;
      for(int i = 1; i &lt;= m_length; i++)
      {
        val++;
        if( value == temp->getValue())
        {
          return(val);
        }
        else
        {
          temp = temp->getNext();
        }
      }
      return(0);
    }	
&lt;/code&gt; </pre>
      
      <p># addBack( T value ) method</p>
      <ul>
        <li>Preconditions: The value 'T' is valid </li>
        <li>Postconditions: A single, new element is created and added to the back of the list </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Add a new element to the end of the list</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::addBack( T value ) const
    {
      if(m_length == 0)
      {
        addFront(value);
      }
      else 
      {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value);
        Node&lt;T&gt;* temp = m_front;
        while(temp -> getNext() != nullptr)
        {
          temp = temp -> getNext();
        }
        temp -> setNext(newNode);
        m_length++;
      }
    }	
&lt;/code&gt; </pre>
     
      <p># addFront( T value ) method</p>
      <ul>
        <li>Preconditions: The value 'T' is valid </li>
        <li>Postconditions: A single, new element is created and added to the front of the list </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Adds a new element to the front of the list</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::addFront( T value ) const
    {
      Node&lt;T&gt; temp = new Node&lt;T&gt;(value);
      if(m_length == 0)
      {
        m_front = temp;
      }
      else 
      {
        temp -> setNext(m_front);
        m_front = temp;
      }
      m_length++;
    }
&lt;/code&gt; </pre>
     
      <p># insert( int position, T value ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: A single, new element is created and added in the position specified </li>
        <li>Parameters: Templated value and an integer representing the index at which the value is to be added</li>
        <li>Access: Public </li>
        <li>Action: Returns 'true' if the value was inserted at the given position, 'false' otherwise. NOTE: Position must fall between 0 and m_size (the number of elements in the list at the time of inserting)</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::insert(int position, T value)
    {
      if((position &lt;= 0) || (position > (m_length+1)))
      {
        return(false);
      }
      else if(position == 1)
      {
        addFront(value);
        return(true);
      }
      else if(position == (m_length+1))
      {
        addBack(value);
        return(true);
      }
      else
      {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value);
        Node&lt;T&gt;* temp = m_front;
        Node&lt;T&gt;* temp2 = m_front;
        for(int i = 1; i &lt;= (position-1); i++)
        {
          temp = temp->getNext();
        }
        for(int i = 1; i &lt; (position-1); i++)
        {
          temp2 = temp2 -> getNext();
        }

        temp2 -> setNext(newNode);
        newNode -> setNext(temp);
        m_length++;
        return(true);
      }
    }
&lt;/code&gt; </pre>
     
      <p># removeBack( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: One element is removed from the back of the list </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Returns 'true' if the element at the end of the list is removed, 'false' if the list is empty</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::removeBack( )
    {
      if(m_length == 0)
      {
        return(false);
      }
      else if(m_length == 1)
      {
        removeFront();
        return(true);
      }
      else
      {
        Node&lt;T&gt;* temp = m_front;
        Node&lt;T&gt;* temp2 = m_front;
        for(int i = 1; i &lt;= (m_length-1); i++)
        {
          temp = temp -> getNext();
        }
        for(int i = 1; i &lt; m_length-1; i++)
        {
          temp2 = temp2 -> getNext();
        }
        delete temp;
        temp2 -> setNext(nullptr);
        m_length = m_length - 1;
        return(true);
      }
    }
&lt;/code&gt; </pre>
      
      <p># removeFront( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: One element is removed from the front of the list </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Return 'true' if the element at the front of the list is removed, 'false' if the list is empty</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::removeFront( )
    {
      if(m_length == 0)
      {
        return(false);
      }
      else
      {
        Node&lt;T&gt;* temp = m_front -> getNext();
        delete m_front;
        m_front = temp;
        m_length--;
        return(true);
      }
    }
&lt;/code&gt; </pre>
      
      <p># removeAt( int position ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The element that is in the specified position is removed from the list </li>
        <li>Parameters: Integer representing the index at which you wish to remove a value </li>
        <li>Access: Public </li>
        <li>Action: Returns 'true' if the element at the given position is removed, 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::removeAt(int position)
    {
      if((m_length == 0) || (position &lt;= 0) || (position > m_length))
      {
        return(false);
      }
      else if(position == 1)
      {
        removeFront();
        return(true);
      }
      else if( position == m_length)
      {
        removeBack();
        return(true);
      }
      else
      {
        Node&lt;T&gt;* temp = m_front;
        Node&lt;T&gt;* temp2 = m_front;
        for(int i = 1; i &lt;= position; i++)
        {
          temp = temp -> getNext();
        }
        for(int i = 1; i &lt; (position-1); i++)
        {
          temp2 = temp2 -> getNext();
        }
        delete temp2 -> getNext();
        temp2 -> setNext(temp);
        m_length--;
        return(true);
      }
    }
&lt;/code&gt; </pre>
      
      <p># setEntry( int position, T value ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The value at the given position is overridden with the value passed in </li>
        <li>Parameters: Integer representing the index you wish to change the value and the value you want </li>
        <li>Access: Public </li>
        <li>Action: The value at the given position is overridden with the value passed in. If the position is beyond the size of the list, the user is notified</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::setEntry(int position, T value)
    {
      Node&lt;T&gt;* temp = m_front;
        for(int i = 1; i &lt; position; i++)
        {
          temp = temp -> getNext();
        }
        temp -> setValue(value);
    }
&lt;/code&gt; </pre>
      
<!--   =============================   -->
      
      <p># getEntry( int position ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: Interger representing the index you wish to have the value returned </li>
        <li>Access: Public </li>
        <li>Action: Returns the value associated with the index that is passed in</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    T& LinkedList&lt;T&gt;::getEntry(int position)
    {
        Node&lt;T&gt;* temp = m_front;
        if (position&lt;1 || position>m_length)
        {
        std::cout&lt;&lt;"Invalid Entry - Out of range.\n";
            //throw(std::runtime_error("Invalid Entry - Out of range"));
        }
        else if (position == 1)
        {
            return m_front->getValue();
        }
        else
        {
            for (int i=0; i&lt;position-1; i++)
            {
                temp = temp->getNext();
            }
            return temp->getValue();
        }
    }
&lt;/code&gt; </pre>
      
<!--   =============================   -->      

      <p># isFound( std::string name2 ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: Stirng representing the name of a potential event</li>
        <li>Access: Public </li>
        <li>Action: The list is traversed and if an event exists with the same name as the one passed in 'true' is returned, 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::isFound(std::string name2)
    {
      Node&lt;T&gt;* temp = m_front;
      T temp1 = temp -> getValue();
      bool found = false;
      while(temp != nullptr)
      {
        temp1 = temp -> getValue();
        if(temp1.getName() == name2)
        {
          found = true;
          return(found);
          break;
        }
        else{
          temp = temp -> getNext();
        }
      }
      return(found);
    }
&lt;/code&gt; </pre>
      
      <p># search( T value ) method</p>
      <ul>
        <li>Preconditions: The value for 'T' is valid </li>
        <li>Postconditions: None </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: The list is searched and if the value passed in is found 'true' is returned, 'false' signifies that the value does not exist in the lsit</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    T& LinkedList&lt;T&gt;::search(std::string name)
    {
      Node&lt;T&gt;* temp = m_front;
      T temp1 = temp ->getValue();
      while(temp != nullptr)
      {
        temp1 = temp -> getValue();
        if(temp1.getName() == name)
        {
          return(temp1);
          break;
        }
        else{
          temp = temp -> getNext();
        }
      }
      T empty;
      return(empty);
    }
&lt;/code&gt; </pre>
      
      <p># sortListEvent( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The LinkedList is sorted by events </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: The list is traversed and sorted by dates</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::sortListEvent()
    {
      Node&lt;T&gt;* currentNode = nullptr;
      Node&lt;T&gt;* prevNode = nullptr;
      Node&lt;T&gt;* temp = nullptr;

        if(m_length == 1)
        {
        //already sorted since there is only one
        }
        else if(m_length == 2)
        {
            currentNode = m_front;
            if (compareEvent((currentNode -> getValue()), (currentNode -> getNext() -> getValue())) == true)
            {
                addBack(currentNode -> getValue());
                removeFront();
            }
        }
        else
        {
            for(int i = 1; i &lt;= m_length; i++)
            {
                currentNode = m_front;
                prevNode = m_front;

                while(currentNode -> getNext() != nullptr)
                {
                  if (compareEvent(currentNode -> getValue(), currentNode -> getNext() -> getValue()) == true)
                    {
                    temp = currentNode -> getNext();
                    currentNode -> setNext(currentNode -> getNext() -> getNext());
                    temp -> setNext(currentNode);

                    if(currentNode == m_front)
                            {
                                prevNode = temp;
                                m_front = prevNode;
                            }
                    else
                            {
                                prevNode -> setNext(temp);
                        currentNode = temp;
                            }
                    }
                  prevNode = currentNode;
                  currentNode = currentNode -> getNext();
                }
              }
        }
    }
&lt;/code&gt; </pre>
      
      <p># compareEvent( T event1, T event2 ) method</p>
      <ul>
        <li>Preconditions: Both 'T' values are valid </li>
        <li>Postconditions: None </li>
        <li>Parameters: Two templated values </li>
        <li>Access: Public </li>
        <li>Action: The two values are compared, if event1 occurs before event2 'true' is returned, 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::compareEvent(T event1, T event2)
    {
        bool isTrue = false;

        if(event1.getYear() > event2.getYear())
        {
            isTrue = true;
            return(isTrue);
        }
        if(event1.getYear() == event2.getYear() && event1.getMonth() > event2.getMonth())
        {
            isTrue = true;
            return(isTrue);
        }
        if(event1.getYear() == event2.getYear() && event1.getMonth() == event2.getMonth() && event1.getDay() > event2.getDay())
        {
            isTrue = true;
            return(isTrue);
        }
      else{
        //nothing happens, false is returned outside the if statements
      }
        return(isTrue);
    }
&lt;/code&gt; </pre>
     
      <p># sortListTime( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The LinkedList of times is sorted </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: The list is traversed and sorted by time</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::sortListTime()
    {
      Node&lt;T&gt;* currentNode = nullptr;
      Node&lt;T&gt;* prevNode = nullptr;
      Node&lt;T&gt;* temp = nullptr;

        if(m_length == 1)
        {
        //already sorted since there is only one
        }
        else if(m_length == 2)
        {
            currentNode = m_front;
            if (compareTime(currentNode -> getValue(), currentNode -> getNext() -> getValue()) == true)
            {
                addBack(currentNode -> getValue());
                removeFront();
            }
        }
        else
        {
            for(int i = 1; i &lt;= m_length; i++)
            {
                currentNode = m_front;
                prevNode = m_front;

            while(currentNode -> getNext() != nullptr)
            {
              if (compareTime(currentNode -> getValue(), currentNode -> getNext() -> getValue()) == true)
                {
                temp = currentNode -> getNext();
                currentNode -> setNext(currentNode -> getNext() -> getNext());
                temp -> setNext(currentNode);

                if(currentNode == m_front)
                        {
                            prevNode = temp;
                            m_front = prevNode;
                        }
                else
                        {
                            prevNode -> setNext(temp);
                    currentNode = temp;
                        }
                }
              prevNode = currentNode;
              currentNode = currentNode -> getNext();
            }
          }
        }
    }
&lt;/code&gt; </pre>
      
      <p># compareTime( T time1, T time2 ) method</p>
      <ul>
        <li>Preconditions: Both 'T' values are valid </li>
        <li>Postconditions: None </li>
        <li>Parameters: Two templated values </li>
        <li>Access: Public </li>
        <li>Action: The two values are compared, if time1 occurs before time2 'true' is returnd, 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::compareTime(T time1, T time2)
    {
      bool isTrue = false;

        if(time1.getTimeslot() > time2.getTimeslot())
        {
            isTrue = true;
            return(isTrue);
        }
      else{
        //nothing happens, false is returned after this
      }
        return(isTrue);
    }
&lt;/code&gt; </pre>
      
<!--  node   -->

      <h3 id="node"> Node.h & Node.hpp</h3>
      
      <p># Node( T value ) method</p>
      <ul>
        <li>Preconditions: Node </li>
        <li>Postconditions: A node with the passed value is created </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Creates a new node with the vallue that is passed in</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    Node&lt;T&gt;::Node(T value)
    {
      m_next = nullptr;
      m_value = value;
    }
&lt;/code&gt; </pre>
      
      <p># T& getValue() method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Returns the value that is associate with any given node</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    T& Node&lt;T&gt;::getValue()
    {
      return(m_value);
    }
&lt;/code&gt; </pre>
      
      <p># setValue( T value ) method</p>
      <ul>
        <li>Preconditions: The value for 'T' is valid </li>
        <li>Postconditions: The value for a node is set </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Sets the value of a node equal to the value passed in</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void Node&lt;T&gt;::setValue(T value)
    {
      m_value = value;
    }
&lt;/code&gt; </pre>
      
      <p># getNext( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Returns a pointer to the node that follows the current</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    Node&lt;T&gt;* Node&lt;T&gt;::getNext() const
    {
      return(m_next);
    }
&lt;/code&gt; </pre>
      
      <p># setNext( Node&lt;T&gt; next ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: Sets the next node to a pointer given by the user </li>
        <li>Parameters: A node pointer representing the next value in a data structure </li>
        <li>Access: Public </li>
        <li>Action: Sets the next node in a structure equal to the pointer that is passed in a parameter</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void Node&lt;T&gt;::setNext(Node&lt;T&gt;* next)
    {
      m_next = next;
    }
&lt;/code&gt; </pre>
            
<!--   Event    -->

      <h3 id="event-class"> Events.h & Events.cpp</h3>
      <ul>
        <li>Show</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', show_votes_counter:true});
    })	
&lt;/code&gt; </pre>
      <ul>
        <li>Hide</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', votes_label:false});
    })	
&lt;/code&gt;</pre>
      
<!--   time slots    -->

      <h3 id="time-slots"> TimeSlots.h & TimeSlots.cpp</h3>
      
      <p># .... method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: None </li>
        <li>Action: None</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', animation_speed:'slow'});
    })	
&lt;/code&gt; </pre>
      
      <p># .... method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: None </li>
        <li>Action: None</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', animation_speed:'slow'});
    })	
&lt;/code&gt; </pre>
      
      <p># .... method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: None </li>
        <li>Action: None</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    $(document).ready(function (){
    $('#opineo').opineo('results.php', {curvalue:0, view: 'mini', animation_speed:'slow'});
    })	
&lt;/code&gt; </pre>
      
    <p><br><br><br><br><br></p>
      
    </div>
  </div>
</section>
<section class="vibrant centered">
  <div class="container">
    <h4> This documentation template is provided free by eGrappler.com. <a href="https://www.egrappler.com/free-product-documentation-html-template/" target="_blank">Source.</a></h4>
  </div>
</section>

</html>

<script>

  function toTop() {
    window.scroll(0,0);
  }

  function toBottom() {
    window.scroll(0,document.body.scrollHeight);
  }
</script>
