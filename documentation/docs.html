<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>cal448 - Documentation</title>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:700,300" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="css/style.css">
<link rel="stylesheet" href="css/prettify.css">
  
<script src="js/jquery.min.js"></script>  
<script type="text/javascript" src="js/prettify/prettify.js"></script> 
<script src="js/layout.js"></script>
<script src="js/jquery.localscroll-1.2.7.js" type="text/javascript"></script>
<script src="js/jquery.scrollTo-1.4.3.1.js" type="text/javascript"></script>
  
</head>

<nav>
  <div class="container">
    <img class="header-image" src="grey-logo-vector.png">
    <div id="menu">
      <ul class="toplinks">
        <li><a href="https://github.com/sahilhirani/EECS_448" target="_blank">GitHub Link </a></li>
      </ul>
    </div>
    <a id="menu-toggle" href="#" class=" ">&#9776;</a> 
  </div>
</nav>
<header>
  <div class="container">
    <h2 class="docs-header"> <strong>cal</strong>448 - Documentation</h2>
  </div>
</header>
<section>
  <div class="container">
    
<!--  the list below is the side navigation, linking not working properly  -->
    
    <ul class="docs-nav" id="menu-left">
      <li><strong>Getting Started</strong></li>
      <li><a href="#welcome">Welcome</a></li>
      <li><a href="#use">How to Use</a></li>
      <li><a href="#features" class=" ">Features</a></li>
      <li><a href="#license" class=" ">License</a></li>
      <li class="separator"></li>
      <li><strong>cal448 Classes & Files</strong></li>
      <li><a href="#main-cpp" class=" ">Main.cpp</a></li>
      <li><a href="#executive" class=" ">Executive Class</a></li>
      <li><a href="#linked-list" class=" ">LinkedList Class</a></li>
      <li><a href="#node" class=" ">Node Class</a></li>
      <li><a href="#event-class" class=" ">Events Class</a></li>
      <li><a href="#time-slots" class=" ">Time Slots Class</a></li>
    </ul>
    
<!--  getting started/welcome section  -->
    
    <div class="docs-content">
      <h2> Getting Started</h2>
      <h3 id="welcome"> Welcome</h3>
      <p> Are you ready to experience truly optimized scheduling?</p>
      
      <p>
        <strong>cal</strong>448 aims to provide users with an efficient and easy to use option to the confusing world of scheduling. Our terminal based application is built using the highest standards and we're sure that you'll love using it! Scroll down to get started and to find in-depth documentation for each of the classes used. With <strong>cal</strong>448 users are able to:
      </p>

      <ul>
        <li>Choose between an Admin or User Mode</li>
        <li>Create truly personalized events</li>
        <li>Assign availability and view number of attendees</li>
      </ul>
      
      <p>
        <strong>cal</strong>448 allows users to do all of this and so much more without having to use a convoluted web or desktop application. Everything is as simple as it can possibly be! For instructions on how to use <strong>cal</strong>448, scroll down to the <a href="#use">How to Use</a> section.
      </p>
      
<!--   how to use section   -->
      
      <h3 id="use"> How to Use</h3>
      <p>
        To install:
      </p>
      
      <ul>
        <li>Head to the GitHub page linked at the <a onclick="toTop()">top</a> of this site</li>
        <li>Clone or download a zip of the project</li>
        <li>Open terminal and navigate to the directory that the project was cloned/downloaded to</li>
        <li>Once in the correct directory, type "make". The program should now compile</li>
        <li>After the program completes compiling, simply type "./cal488" and the program will run</li>
      </ul>
      
      <p>In pictures (after clone/download):</p>
      
      <img class="instruction-imgs" src="/documentation/images/1.png">
      <img class="instruction-imgs" src="/documentation/images/2.png">
      <img class="instruction-imgs" src="/documentation/images/3.png">
      
<!--   features section   -->
      
      <h3 id="features"> Features</h3>
      <ul>
        <li>Scheduling in a simplified and easy manner</li>
        <li>Ability to see number of attendees for events</li>
        <li>Codebase in C++ allowing for simple understanding</li>
        <li>Functional user interface that works (no guessing)</li>
      </ul>
      
<!--   license section   -->
      
      <h3 id="license"> License</h3>
      <p> 
        <strong>cal</strong>448 holds an <a href="https://opensource.org/licenses/MIT" target="_blank">MIT license.</a> This means that all code provided is free of charge and can be modified to fit the needs of you or your organization. No reference to the project page on GitHub is required. This project's documentation website is sourced from eGrappler. Link provided at the <a onclick="toBottom()">bottom</a> of this site.
      </p>
      
      <hr>
      
      <h2> <strong>cal</strong>448 Classes & Files</h2>
      <p>
        Below you will find every function/method/class variable used in <strong>cal</strong>448
      </p>
      
<!--   this is where the classes are documented   -->
      
      <h3 id="main-cpp"> Main.cpp</h3>
      <p># main( ) function</p>
      <ul>
        <li>Preconditions: None</li>
        <li>Postconditions: None</li>
        <li>Parameters: None</li>
        <li>Access: Public</li>
        <li>Action: Creates an instance of the Executive class and runs the program.</li>
      </ul>
      
      <pre class="prettyprint">&lt;code&gt;
    int main() 
    {
      Executive exec;
      exec.run();

      return(0);
    }
&lt;/code&gt;</pre>
      
<!--   Executive   -->
      
      <h3 id="executive"> Executive.h & Executive.cpp</h3>
      <p><strong>Due to the longer length of methods, code for the Exectutive class will not be posted here. Thank you for your understanding.</strong></p>
      
      <p># Executive( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: Private member variables are set and the list of events is populated </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: The list of events is populated from a file and the member variables are initialized or set up to be used</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    code can be found on the GitHub page
&lt;/code&gt; </pre>
      
      <p># ~Executive( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Empty destructor</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    code can be found on the GitHub page
&lt;/code&gt; </pre>
      
      <p># run( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: Program begins </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: The program begins and the user can interact with it</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    code can be found on the GitHub page
&lt;/code&gt; </pre>
      
      <p># adminFunc( bool mode12 ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: Admin mode begins </li>
        <li>Parameters: Boolean checking whether the user has selected 12 or 24 hour mode </li>
        <li>Access: Private </li>
        <li>Action: The program initializes the admin mode</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    code can be found on the GitHub page
&lt;/code&gt; </pre>
     
      <p># userFunc( bool mode12 ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: User mode begins </li>
        <li>Parameters: Boolean checking whether the user has selected 12 or 24 hour mode </li>
        <li>Access: Private </li>
        <li>Action: The program initializes the user mode</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    code can be found on the GitHub page
&lt;/code&gt; </pre>
      
      <p># addEvent( bool mode12 ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: An event is added to the list of events </li>
        <li>Parameters: Boolean checking whether the user has selected 12 or 24 hour mode </li>
        <li>Access: Private </li>
        <li>Action: The program allows the user to add an event</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    code can be found on the GitHub page
&lt;/code&gt; </pre>

<!--  linked list    -->

      <h3 id="linked-list"> LinkedList.h & LinkedList.hpp</h3>
      
      <p># LinkedList( ) method</p>
      <ul>
        <li>Preconditions: None</li>
        <li>Postconditions: An empty LinkedList object is created</li>
        <li>Parameters: None</li>
        <li>Access: Public</li>
        <li>Action: Assigns private member variables and creates an empty list</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    LinkedList&lt;T&gt;::LinkedList()
    {
      m_front = nullptr;
      m_length = 0;
    }
&lt;/code&gt; </pre>
      
      <p># ~LinkedList( ) method</p>
      <ul>
        <li>Preconditions: None</li>
        <li>Postconditions: All nodes in the LinkedList object are deleted</li>
        <li>Parameters: None</li>
        <li>Access: Public</li>
        <li>Action: Each element in the list is traversed and removed until no more exist</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    LinkedList&lt;T&gt;::~LinkedList( )
    {
      while(m_front != nullptr) 
      {
        removeFront();
      }
    }
&lt;/code&gt; </pre>
      
      <p># isEmpty( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Checks to see if the value associated with the private member variable 'm_length' is greater than 0. If it is, 'false' will be returned. 'true' otherwise. </li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::isEmpty( )
    {
      if(m_length == 0) 
      {
        return(true);
      }
      else
      {
        return(false);
      }
    }	
&lt;/code&gt; </pre>
     
      <p># getLength( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Returns the value associated with the number of nodes that are in the list at the time called.</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    int LinkedList&lt;T&gt;::getLength( ) const
    {
      return(m_length);
    }
&lt;/code&gt; </pre>
      
      <p># positionOf( T value ) method</p>
      <ul>
        <li>Preconditions: T's type is overloaded with the '==' operator </li>
        <li>Postconditions: None </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Returns the index associated with the templated value. If it does not exist in the list, the user is notified.</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    int LinkedList&lt;T&gt;::positionOf( T value ) const
    {
      int val = 0;
      Node&lt;T&gt;* temp = m_front;
      for(int i = 1; i &lt;= m_length; i++)
      {
        val++;
        if( value == temp->getValue())
        {
          return(val);
        }
        else
        {
          temp = temp->getNext();
        }
      }
      return(0);
    }	
&lt;/code&gt; </pre>
      
      <p># addBack( T value ) method</p>
      <ul>
        <li>Preconditions: The value 'T' is valid </li>
        <li>Postconditions: A single, new element is created and added to the back of the list </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Add a new element to the end of the list</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::addBack( T value ) const
    {
      if(m_length == 0)
      {
        addFront(value);
      }
      else 
      {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value);
        Node&lt;T&gt;* temp = m_front;
        while(temp -> getNext() != nullptr)
        {
          temp = temp -> getNext();
        }
        temp -> setNext(newNode);
        m_length++;
      }
    }	
&lt;/code&gt; </pre>
     
      <p># addFront( T value ) method</p>
      <ul>
        <li>Preconditions: The value 'T' is valid </li>
        <li>Postconditions: A single, new element is created and added to the front of the list </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Adds a new element to the front of the list</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::addFront( T value ) const
    {
      Node&lt;T&gt; temp = new Node&lt;T&gt;(value);
      if(m_length == 0)
      {
        m_front = temp;
      }
      else 
      {
        temp -> setNext(m_front);
        m_front = temp;
      }
      m_length++;
    }
&lt;/code&gt; </pre>
     
      <p># insert( int position, T value ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: A single, new element is created and added in the position specified </li>
        <li>Parameters: Templated value and an integer representing the index at which the value is to be added</li>
        <li>Access: Public </li>
        <li>Action: Returns 'true' if the value was inserted at the given position, 'false' otherwise. NOTE: Position must fall between 0 and m_size (the number of elements in the list at the time of inserting)</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::insert(int position, T value)
    {
      if((position &lt;= 0) || (position > (m_length+1)))
      {
        return(false);
      }
      else if(position == 1)
      {
        addFront(value);
        return(true);
      }
      else if(position == (m_length+1))
      {
        addBack(value);
        return(true);
      }
      else
      {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value);
        Node&lt;T&gt;* temp = m_front;
        Node&lt;T&gt;* temp2 = m_front;
        for(int i = 1; i &lt;= (position-1); i++)
        {
          temp = temp->getNext();
        }
        for(int i = 1; i &lt; (position-1); i++)
        {
          temp2 = temp2 -> getNext();
        }

        temp2 -> setNext(newNode);
        newNode -> setNext(temp);
        m_length++;
        return(true);
      }
    }
&lt;/code&gt; </pre>
     
      <p># removeBack( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: One element is removed from the back of the list </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Returns 'true' if the element at the end of the list is removed, 'false' if the list is empty</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::removeBack( )
    {
      if(m_length == 0)
      {
        return(false);
      }
      else if(m_length == 1)
      {
        removeFront();
        return(true);
      }
      else
      {
        Node&lt;T&gt;* temp = m_front;
        Node&lt;T&gt;* temp2 = m_front;
        for(int i = 1; i &lt;= (m_length-1); i++)
        {
          temp = temp -> getNext();
        }
        for(int i = 1; i &lt; m_length-1; i++)
        {
          temp2 = temp2 -> getNext();
        }
        delete temp;
        temp2 -> setNext(nullptr);
        m_length = m_length - 1;
        return(true);
      }
    }
&lt;/code&gt; </pre>
      
      <p># removeFront( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: One element is removed from the front of the list </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Return 'true' if the element at the front of the list is removed, 'false' if the list is empty</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::removeFront( )
    {
      if(m_length == 0)
      {
        return(false);
      }
      else
      {
        Node&lt;T&gt;* temp = m_front -> getNext();
        delete m_front;
        m_front = temp;
        m_length--;
        return(true);
      }
    }
&lt;/code&gt; </pre>
      
      <p># removeAt( int position ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The element that is in the specified position is removed from the list </li>
        <li>Parameters: Integer representing the index at which you wish to remove a value </li>
        <li>Access: Public </li>
        <li>Action: Returns 'true' if the element at the given position is removed, 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::removeAt(int position)
    {
      if((m_length == 0) || (position &lt;= 0) || (position > m_length))
      {
        return(false);
      }
      else if(position == 1)
      {
        removeFront();
        return(true);
      }
      else if( position == m_length)
      {
        removeBack();
        return(true);
      }
      else
      {
        Node&lt;T&gt;* temp = m_front;
        Node&lt;T&gt;* temp2 = m_front;
        for(int i = 1; i &lt;= position; i++)
        {
          temp = temp -> getNext();
        }
        for(int i = 1; i &lt; (position-1); i++)
        {
          temp2 = temp2 -> getNext();
        }
        delete temp2 -> getNext();
        temp2 -> setNext(temp);
        m_length--;
        return(true);
      }
    }
&lt;/code&gt; </pre>
      
      <p># setEntry( int position, T value ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The value at the given position is overridden with the value passed in </li>
        <li>Parameters: Integer representing the index you wish to change the value and the value you want </li>
        <li>Access: Public </li>
        <li>Action: The value at the given position is overridden with the value passed in. If the position is beyond the size of the list, the user is notified</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::setEntry(int position, T value)
    {
      Node&lt;T&gt;* temp = m_front;
        for(int i = 1; i &lt; position; i++)
        {
          temp = temp -> getNext();
        }
        temp -> setValue(value);
    }
&lt;/code&gt; </pre>
      
<!--   =============================   -->
      
      <p># getEntry( int position ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: Interger representing the index you wish to have the value returned </li>
        <li>Access: Public </li>
        <li>Action: Returns the value associated with the index that is passed in</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    T& LinkedList&lt;T&gt;::getEntry(int position)
    {
        Node&lt;T&gt;* temp = m_front;
        if (position&lt;1 || position>m_length)
        {
        std::cout&lt;&lt;"Invalid Entry - Out of range.\n";
            //throw(std::runtime_error("Invalid Entry - Out of range"));
        }
        else if (position == 1)
        {
            return m_front->getValue();
        }
        else
        {
            for (int i=0; i&lt;position-1; i++)
            {
                temp = temp->getNext();
            }
            return temp->getValue();
        }
    }
&lt;/code&gt; </pre>
      
<!--   =============================   -->      

      <p># isFound( std::string name2 ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: Stirng representing the name of a potential event</li>
        <li>Access: Public </li>
        <li>Action: The list is traversed and if an event exists with the same name as the one passed in 'true' is returned, 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::isFound(std::string name2)
    {
      Node&lt;T&gt;* temp = m_front;
      T temp1 = temp -> getValue();
      bool found = false;
      while(temp != nullptr)
      {
        temp1 = temp -> getValue();
        if(temp1.getName() == name2)
        {
          found = true;
          return(found);
          break;
        }
        else{
          temp = temp -> getNext();
        }
      }
      return(found);
    }
&lt;/code&gt; </pre>
      
      <p># search( T value ) method</p>
      <ul>
        <li>Preconditions: The value for 'T' is valid </li>
        <li>Postconditions: None </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: The list is searched and if the value passed in is found 'true' is returned, 'false' signifies that the value does not exist in the lsit</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    T& LinkedList&lt;T&gt;::search(std::string name)
    {
      Node&lt;T&gt;* temp = m_front;
      T temp1 = temp ->getValue();
      while(temp != nullptr)
      {
        temp1 = temp -> getValue();
        if(temp1.getName() == name)
        {
          return(temp1);
          break;
        }
        else{
          temp = temp -> getNext();
        }
      }
      T empty;
      return(empty);
    }
&lt;/code&gt; </pre>
      
      <p># sortListEvent( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The LinkedList is sorted by events </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: The list is traversed and sorted by dates</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::sortListEvent()
    {
      Node&lt;T&gt;* currentNode = nullptr;
      Node&lt;T&gt;* prevNode = nullptr;
      Node&lt;T&gt;* temp = nullptr;

        if(m_length == 1)
        {
        //already sorted since there is only one
        }
        else if(m_length == 2)
        {
            currentNode = m_front;
            if (compareEvent((currentNode -> getValue()), (currentNode -> getNext() -> getValue())) == true)
            {
                addBack(currentNode -> getValue());
                removeFront();
            }
        }
        else
        {
            for(int i = 1; i &lt;= m_length; i++)
            {
                currentNode = m_front;
                prevNode = m_front;

                while(currentNode -> getNext() != nullptr)
                {
                  if (compareEvent(currentNode -> getValue(), currentNode -> getNext() -> getValue()) == true)
                    {
                    temp = currentNode -> getNext();
                    currentNode -> setNext(currentNode -> getNext() -> getNext());
                    temp -> setNext(currentNode);

                    if(currentNode == m_front)
                            {
                                prevNode = temp;
                                m_front = prevNode;
                            }
                    else
                            {
                                prevNode -> setNext(temp);
                        currentNode = temp;
                            }
                    }
                  prevNode = currentNode;
                  currentNode = currentNode -> getNext();
                }
              }
        }
    }
&lt;/code&gt; </pre>
      
      <p># compareEvent( T event1, T event2 ) method</p>
      <ul>
        <li>Preconditions: Both 'T' values are valid </li>
        <li>Postconditions: None </li>
        <li>Parameters: Two templated values </li>
        <li>Access: Public </li>
        <li>Action: The two values are compared, if event1 occurs before event2 'true' is returned, 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::compareEvent(T event1, T event2)
    {
        bool isTrue = false;

        if(event1.getYear() > event2.getYear())
        {
            isTrue = true;
            return(isTrue);
        }
        if(event1.getYear() == event2.getYear() && event1.getMonth() > event2.getMonth())
        {
            isTrue = true;
            return(isTrue);
        }
        if(event1.getYear() == event2.getYear() && event1.getMonth() == event2.getMonth() && event1.getDay() > event2.getDay())
        {
            isTrue = true;
            return(isTrue);
        }
      else{
        //nothing happens, false is returned outside the if statements
      }
        return(isTrue);
    }
&lt;/code&gt; </pre>
     
      <p># sortListTime( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The LinkedList of times is sorted </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: The list is traversed and sorted by time</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void LinkedList&lt;T&gt;::sortListTime()
    {
      Node&lt;T&gt;* currentNode = nullptr;
      Node&lt;T&gt;* prevNode = nullptr;
      Node&lt;T&gt;* temp = nullptr;

        if(m_length == 1)
        {
        //already sorted since there is only one
        }
        else if(m_length == 2)
        {
            currentNode = m_front;
            if (compareTime(currentNode -> getValue(), currentNode -> getNext() -> getValue()) == true)
            {
                addBack(currentNode -> getValue());
                removeFront();
            }
        }
        else
        {
            for(int i = 1; i &lt;= m_length; i++)
            {
                currentNode = m_front;
                prevNode = m_front;

            while(currentNode -> getNext() != nullptr)
            {
              if (compareTime(currentNode -> getValue(), currentNode -> getNext() -> getValue()) == true)
                {
                temp = currentNode -> getNext();
                currentNode -> setNext(currentNode -> getNext() -> getNext());
                temp -> setNext(currentNode);

                if(currentNode == m_front)
                        {
                            prevNode = temp;
                            m_front = prevNode;
                        }
                else
                        {
                            prevNode -> setNext(temp);
                    currentNode = temp;
                        }
                }
              prevNode = currentNode;
              currentNode = currentNode -> getNext();
            }
          }
        }
    }
&lt;/code&gt; </pre>
      
      <p># compareTime( T time1, T time2 ) method</p>
      <ul>
        <li>Preconditions: Both 'T' values are valid </li>
        <li>Postconditions: None </li>
        <li>Parameters: Two templated values </li>
        <li>Access: Public </li>
        <li>Action: The two values are compared, if time1 occurs before time2 'true' is returnd, 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool LinkedList&lt;T&gt;::compareTime(T time1, T time2)
    {
      bool isTrue = false;

        if(time1.getTimeslot() > time2.getTimeslot())
        {
            isTrue = true;
            return(isTrue);
        }
      else{
        //nothing happens, false is returned after this
      }
        return(isTrue);
    }
&lt;/code&gt; </pre>
      
<!--  node   -->

      <h3 id="node"> Node.h & Node.hpp</h3>
      
      <p># Node( T value ) method</p>
      <ul>
        <li>Preconditions: Node </li>
        <li>Postconditions: A node with the passed value is created </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Creates a new node with the vallue that is passed in</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    Node&lt;T&gt;::Node(T value)
    {
      m_next = nullptr;
      m_value = value;
    }
&lt;/code&gt; </pre>
      
      <p># T& getValue() method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Returns the value that is associate with any given node</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    T& Node&lt;T&gt;::getValue()
    {
      return(m_value);
    }
&lt;/code&gt; </pre>
      
      <p># setValue( T value ) method</p>
      <ul>
        <li>Preconditions: The value for 'T' is valid </li>
        <li>Postconditions: The value for a node is set </li>
        <li>Parameters: Templated value </li>
        <li>Access: Public </li>
        <li>Action: Sets the value of a node equal to the value passed in</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void Node&lt;T&gt;::setValue(T value)
    {
      m_value = value;
    }
&lt;/code&gt; </pre>
      
      <p># getNext( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Returns a pointer to the node that follows the current</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    Node&lt;T&gt;* Node&lt;T&gt;::getNext() const
    {
      return(m_next);
    }
&lt;/code&gt; </pre>
      
      <p># setNext( Node&lt;T&gt; next ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: Sets the next node to a pointer given by the user </li>
        <li>Parameters: A node pointer representing the next value in a data structure </li>
        <li>Access: Public </li>
        <li>Action: Sets the next node in a structure equal to the pointer that is passed in a parameter</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void Node&lt;T&gt;::setNext(Node&lt;T&gt;* next)
    {
      m_next = next;
    }
&lt;/code&gt; </pre>
            
<!--   Event    -->

      <h3 id="event-class"> Events.h & Events.cpp</h3>
      
      <p># Events( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: Assigns member variables a default value and creates an event </li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: Creates an event with default values</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    Events::Events( )
    {
      code/////
    }
&lt;/code&gt; </pre>
     
      <p># Events( std::string name, int month, int day, int year ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: Assigns member variables the corresponding value passed in and creates an event </li>
        <li>Parameters: String for name and integers for month, day and year</li>
        <li>Access: Public </li>
        <li>Action: Creates an event with passed in values</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    Events::Events( std::string name, int month, int day, int year )
    {
      code/////
    }
&lt;/code&gt; </pre>
      
      <p># ~Events( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None</li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: Empty destructor</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    Events::~Events( )
    {
      //empty destructor
    }
&lt;/code&gt; </pre>

      <p># operator>( const Events& rhs ) method</p>
      <ul>
        <li>Preconditions: Valid event object </li>
        <li>Postconditions: Two events are compared</li>
        <li>Parameters: An event reference</li>
        <li>Access: Public </li>
        <li>Action: Two events are compared, if the year of the current event occurs earlier than the one passed in 'true' is returned. 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool Events::operator>(const Events& rhs) const
    {
      // if year on left is greater, then left event starts later. return true
      if (m_year > rhs.getYear())
      {
          return true;
      }
      // if year on left is less than, then right event starts later. return false
      else if (m_year &lt; rhs.getYear())
      {
          return false;
      }
      // else, both events occur in the same year.  Start next set of if-else statements to test for months
      else
      {
          // if month on left is greater, then left event starts later. return true
          if (m_month > rhs.getMonth())
          {
              return true;
          }
          // if month on left is less than, then right event starts later. return false
          else if (m_month &lt; rhs.getMonth())
          {
              return false;
          }
          // else, both events occur in the same month. Start next set of if-else statements to test for days
          else
          {
              // if day on left is greater, then left event starts later. return true
              if (m_day > rhs.getDay())
              {
                  return true;
              }
              // if day on right is greater, then right event starts later. return false
              else if (m_day &lt; rhs.getDay())
              {
                  return false;
              }
              // else, both events occur on the same day. Start next set of if-else statements to test for timeslots
              else
              {
                  // compare the start time of the event on the left side to the start time of the event on the right side.
                  // If the start time on the left is greater than the start time on the right, then it is the later event,
                  // and thus the > operation is true
                  /*if ((m_TimeSlot->getEntry(1)->getTimeSlot()) > (rhs->getTimeSlots()->getEntry(1)->getTimeslot()))
                  {
                      return true;
                  }
                  // If the start time on the left is less than the start time on the right, then it is not the later event,
                  // and thus the > operation is false
                  else if ((m_Timeslot->getEntry(1)->getTimeslot()) &lt; (rhs->getTimeSlots()->getEntry(1)->getTimeslot()))
                  {
                      return false;
                  }
                  // else, these events start at the same time. return false for now, need to discuss this with group before moving forward
                  else
                  {
                      return false;
                  }*/
              }
          }
      }
    }
&lt;/code&gt; </pre>
      
      <p># operator&lt;( const Events& rhs ) method</p>
      <ul>
        <li>Preconditions: Valid event object </li>
        <li>Postconditions: Two events are compared</li>
        <li>Parameters: An event reference</li>
        <li>Access: Public </li>
        <li>Action: Two events are compared, if the year of the current event occurs before than the one passed in 'true' is returned. 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool Events::operator&lt;(const Events& rhs) const
    {
      // if year on left is less than, then right event starts later. return true
      if (m_year &lt; rhs.getYear())
      {
          return true;
      }
      // if year on left is greater, then left event starts later. return false
      else if (m_year > rhs.getYear())
      {
          return false;
      }
      // else, both events occur in the same year.  Start next set of if-else statements to test for months
      else
      {
          // if month on left is less than, then right event starts later. return true
          if (m_month &lt; rhs.getMonth())
          {
              return true;
          }
          // if month on left is greater, then left event starts later. return false
          else if (m_month > rhs.getMonth())
          {
              return false;
          }
          // else, both events occur in the same month. Start next set of if-else statements to test for days
          else
          {
              // if day on left is less than, then right event starts later. return true
              if (m_day &lt; rhs.getDay())
              {
                  return true;
              }
              // if day on left is greater, then left event starts later. return false
              else if (m_day > rhs.getDay())
              {
                  return false;
              }
              // else, both events occur on the same day. Start next set of if-else statements to test for timeslots
              else
              {
                  // compare the start time of the event on the left side to the start time of the event on the right side.
                  // If the start time on the left is less than to the start time on the right, then the right is the later event,
                  // and thus the &lt; operation is true
                  /*if ((m_Timeslot->getEntry(1)->getTimeslot()) &lt; (rhs->getTimeSlots()->getEntry(1)->getTimeslot()))
                  {
                      return true;
                  }
                  // If the start time on the left is greater than the start time on the right, then it is the later event,
                  // and thus the &lt; operation is false
                  else if ((m_Timeslot->getEntry(1)->getTimeslot()) > (rhs->getTimeSlots()->getEntry(1)->getTimeslot()))
                  {
                      return false;
                  }
                  // else, these events start at the same time. return false for now, need to discuss this with group before moving forward
                  else
                  {
                      return false;
                  }*/
              }
          }
      }
    }
&lt;/code&gt; </pre>
      
      <p># operator==( const Events& rhs ) method</p>
      <ul>
        <li>Preconditions: Valid event object </li>
        <li>Postconditions: Two events are compared</li>
        <li>Parameters: An event reference</li>
        <li>Access: Public </li>
        <li>Action: Two events are compared, if the year of the current event is the same as the one passed in 'true' is returned. 'false' otherwise</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    bool Events::operator==(const Events& rhs) const
    {
      // test to see if years are equal
      if (m_year == rhs.getYear())
      {
          // if years are equal, test for months
          if (m_month == rhs.getMonth())
          {
              // if months are equal, test for days
              if (m_day == rhs.getDay())
              {
                  // if days are equal, test for start times
                  /*if ((m_Timeslot->getEntry(1)->getTimeslot()) == (rhs->getTimeSlots()->getEntry(1)->getTimeslot()))
                  {
                      // start times are equal, return true
                      return true;
                  }
                  else
                  {
                      // start times are not equal, return false
                      return false;
                  }*/
              }
              // days are not equal, return false
              else
              {
                  return false;
              }
          }
          // months are not equal, return false
          else
          {
              return false;
          }
      }
      // years are not equal, return false
      else
      {
          return false;
      }
    }
&lt;/code&gt; </pre>
      
      <p># setName( std::string name ) method</p>
      <ul>
        <li>Preconditions: The name is valid </li>
        <li>Postconditions: The private member variable is set to match the parameter</li>
        <li>Parameters: String representing the name of an event</li>
        <li>Access: Public </li>
        <li>Action: Private member variable is assigned correct value</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void Events::setName( std::string name )
    {
      m_name = name;
    }
&lt;/code&gt; </pre>
      
      <p># setMonth( int month ) method</p>
      <ul>
        <li>Preconditions: The month is valid </li>
        <li>Postconditions: The private member variable is set to match the parameter</li>
        <li>Parameters: Int representing the month of an event</li>
        <li>Access: Public </li>
        <li>Action: Private member variable is assigned correct value</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void Events::setMonth( int month )
    {
      m_month = month;
    }
&lt;/code&gt; </pre>
      
      <p># setDay( int day ) method</p>
      <ul>
        <li>Preconditions: The day is valid </li>
        <li>Postconditions: The private member variable is set to match the parameter</li>
        <li>Parameters: Int representing the day of an event</li>
        <li>Access: Public </li>
        <li>Action: Private member variable is assigned correct value</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void Events::setDay( int day )
    {
      m_day = day;
    }
&lt;/code&gt; </pre>
      
      <p># setYear( int year ) method</p>
      <ul>
        <li>Preconditions: The year is valid </li>
        <li>Postconditions: The private member variable is set to match the parameter</li>
        <li>Parameters: Int representing the year of an event</li>
        <li>Access: Public </li>
        <li>Action: Private member variable is assigned correct value</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void Events::setYear( int year )
    {
      m_year = year;
    }
&lt;/code&gt; </pre>
      
      <p># getName( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The name of an event it returned</li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: The name of the event being accessed is returned to the program</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    std::string Events::getName( )
    {
      return m_name;
    }
&lt;/code&gt; </pre>
      
      <p># getMonth( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The month of an event it returned</li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: The month of the event being accessed is returned to the program</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    int Events::getMonth( )
    {
      return m_month;
    }
&lt;/code&gt; </pre>
      
      <p># getDay( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The day of an event it returned</li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: The day of the event being accessed is returned to the program</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    int Events::getDay( )
    {
      return m_day;
    }
&lt;/code&gt; </pre>
      
      <p># getYear( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The year of an event it returned</li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: The year of the event being accessed is returned to the program</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    int Events::getYear( )
    {
      return m_year;
    }
&lt;/code&gt; </pre>
      
      <p># getTimeSlots( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The list of time slots for an event it returned</li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: The list of time slots for the event being accessed is returned to the program</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    LinkedList&lt;T&gt;* Events::getTimeSlots( ) const
    {
      return m_TimeSlot;
    }
&lt;/code&gt; </pre>
      
      <p># getInfo( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: The info for an event is printed</li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: The information for an event is printed out so that the user can see it</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void Events::getInfo( )
    {
      std::cout &lt;&lt; "\n" &lt;&lt; m_name &lt;&lt; " is occuring on " &lt;&lt; m_month &lt;&lt; "/" &lt;&lt; m_day &lt;&lt; "/" &lt;&lt; m_year &lt;&lt; ".\n";
    }
&lt;/code&gt; </pre>
      
<!--   time slots    -->

      <h3 id="time-slots"> TimeSlots.h & TimeSlots.cpp</h3>
      
      <p># TimeSlots( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: Private member variables are set to defaults and a time slot is created </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: A new time slot is created with default values</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    TimeSlots::TimeSlots( )
    {
      m_numOfAtt = 0;
      m_TimeSlot = 0;
    }
&lt;/code&gt; </pre>
      
      <p># ~TimeSlots( ) method</p>
      <ul>
        <li>Preconditions: None </li>
        <li>Postconditions: None </li>
        <li>Parameters: None </li>
        <li>Access: Public </li>
        <li>Action: Empty destructor</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    TimeSlots::~TimeSlots 
    {
      //Empty destructor
    }
&lt;/code&gt; </pre>
      
      <p># TimeSlots( int num, int time ) method</p>
      <ul>
        <li>Preconditions: Valid number of attendees and valid time </li>
        <li>Postconditions: Private member variables are set and a time slot is created </li>
        <li>Parameters: Integers representing time and attendees </li>
        <li>Access: Public </li>
        <li>Action: A new time slot is created with default values</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    TimeSlots::TimeSlots( int num, int time )
    {
      m_numOfAtt = num;
      m_TimeSlot = time;
    }
&lt;/code&gt; </pre>
      
      <p># setNum( int num ) method</p>
      <ul>
        <li>Preconditions: Valid number of attendees</li>
        <li>Postconditions: Private member variable m_numOfAtt is set to passed in value</li>
        <li>Parameters: Integer representing number of attendees </li>
        <li>Access: Public </li>
        <li>Action: The number of attendees is set</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void TimeSlots::setNum( int num )
    {
      m_numOfAtt = num;
    }
&lt;/code&gt; </pre>
      
      <p># setTimeSlot( int time ) method</p>
      <ul>
        <li>Preconditions: Valid time</li>
        <li>Postconditions: Private member variable m_TimeSlot is set to passed in value</li>
        <li>Parameters: Integer representing time </li>
        <li>Access: Public </li>
        <li>Action: The time slot for an attendee is set</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    void TimeSlots::setTimeSlot( int time )
    {
      m_TimeSlot = time;
    }
&lt;/code&gt; </pre>
      
      <p># getTimeSlot( ) method</p>
      <ul>
        <li>Preconditions: None</li>
        <li>Postconditions: None</li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: The time slot for an attendee is returned to the program</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    int TimeSlots::getTimeSlot( )
    {
      return m_TimeSlot;
    }
&lt;/code&gt; </pre>
      
      <p># getNum( ) method</p>
      <ul>
        <li>Preconditions: None</li>
        <li>Postconditions: None</li>
        <li>Parameters: None</li>
        <li>Access: Public </li>
        <li>Action: The number of attendees is returned to the program</li>
      </ul>
      <pre class="prettyprint">&lt;code&gt;
    int TimeSlots::getNum( )
    {
      return m_numOfAtt;
    }
&lt;/code&gt; </pre>
      
    <p><br><br><br><br><br></p>
      
    </div>
  </div>
</section>
<section class="vibrant centered">
  <div class="container">
    <h4> This documentation template is provided free by eGrappler.com. <a href="https://www.egrappler.com/free-product-documentation-html-template/" target="_blank">Source.</a></h4>
  </div>
</section>

</html>

<script>

  function toTop() {
    window.scroll(0,0);
  }

  function toBottom() {
    window.scroll(0,document.body.scrollHeight);
  }
</script>
